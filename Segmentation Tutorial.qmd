---
title: "Segmentation Tutorial"
format:
  html:
    toc: true
self-contained: true
execute:
  fig-width: 8
  fig-height: 6
  dpi: 300
---

# Goal

To show how different choices related to various clustering algorithms systematically change the results to help distinguish when each would be more or less useful/beneficial. The topic of this tutorial is Segmentation, so I will be focused on analyses that cluster people into groups based on their responses to a set of items.

# Setup

This tutorial will run various cluster algorithms (and in some cases try different paramters within one analysis) on a dataset of people's musical genre preferences.

The tutorial will compare the following analyses:

- K Means with raw data as input
- K Means with a person x person correlation matrix as input
- K Means with a person x person similarity matrix (Jaccard) as input
- Latent class analysis

Typically, I would run various checks to identify the optimal cluster number, but for the educational purpose of comparing methods, I will stick to a 4 cluster solution.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, warning = F, message = F)
```

```{r}
# Load packages
pacman::p_load("tidyverse", 
    "factoextra",
    "patchwork",
    'ggplot2',
    'ggrepel',
    'ClusterR', 
    'irlba'
)
```

```{r}
# Load data
dat = read_csv('genre_preferences.csv') %>% 
    drop_na()

# Create a data set with only numeric columns
dat_num = dat %>% 
  select(-ResponseId)

# Number of clusters across analyses
k = 4
```

# K Means - Raw Data

## PCA Biplot

The following figure plots the data along the first two principal components (top 2 dimensions that explain the most variance in the data). The four clusters are color coded and the arrows represent the correlation between the principal components and the original items. Put simply, the direction of the arrow points to where interest is strongest for that genre, the length of the arrow is how important the influence of that genre is to the overall interpretation. Lastly, the 0,0 point basically represents the overall average respondent across all the data.

Cluster interpretations:

- Cluster 1: Tends to like all the genres, generalists (all genres point in that direction)
- Cluster 2: More specific taste for afro-diasporic genres (gospel, R&B, Soul, Jazz, Rap, etc)
- Cluster 3: More specific taste for euro-anglo genres (pop, alt & classic rock, indie, punk metal)
- Cluster 4: Least interested in music genres (some for country, classic rock, pop)

Principal Components interpretations:

- PC1: Magnitude of interest (how many genres are liked)
- PC2: Specific taste of genre (euro-anglo on top, afro-diasporic on bottom)

```{r}
# set seed for reproducibility
set.seed(13)
k_means = kmeans(dat_num, centers = k, nstart = 20)
k_clusters = k_means$cluster

# run PCA
pca <- prcomp(dat_num, scale. = TRUE)

# Plot the biplot
scores <- as.data.frame(pca$x[, 1:2])    # respondent positions
scores$cluster <- factor(k_clusters)    # add cluster assignment

# correlate PCs with original items for arrows
cor_with_items <- cor(scores[,1:2], dat_num, use = "pairwise.complete.obs")
cor_with_items <- as.data.frame(t(cor_with_items))  
cor_with_items$Variable <- rownames(cor_with_items)

arrow_scale <- 10 # to scale the arrows for readability
clusternames = levels(scores$cluster)

# Need to find convex hull of each cluster
hull_points <- scores %>%
  group_by(cluster) %>%
  slice(chull(PC1, PC2))

# cluster plot with arrows and labels
ggplot(scores, aes(x = PC1, y = PC2, color = cluster, shape = cluster)) +
  geom_point(alpha = 0.4) +
  theme_classic() +
  ggtitle("MiniBatchKmeans Clusters (PCA projection)") +
  geom_polygon(data = hull_points, aes(fill = cluster), 
               alpha = 0.1) +
  theme_classic() +
  geom_segment(data = cor_with_items,
               aes(x = 0, y = 0, xend = PC1 * arrow_scale, yend = PC2 * arrow_scale),
               arrow = arrow(length = unit(0.2,"cm")),
               inherit.aes = FALSE, color = "black") +
  ggrepel::geom_text_repel(data = cor_with_items,
               aes(x = PC1 * (arrow_scale + 0.5),
                   y = PC2 * (arrow_scale + 0.5),
                   label = Variable),
               inherit.aes = FALSE,
               size = 5, color = "black", max.overlaps = 100) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey40") + 
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey40") +
  scale_color_discrete(labels = clusternames, name = "Cluster") +
  scale_shape_discrete(labels = clusternames, name = "Cluster") +
  guides(fill = "none") +
  ggtitle('') +
  theme(legend.position = "top",
        legend.direction = "horizontal",
        legend.title = element_text(size = 15),
        legend.text  = element_text(size = 11)) 
```

This highlights one of the likely outcomes of K Means clustering with raw data as input, which uses **euclidean distance** to determine similarity: 

PC1 tends to capture magnitude (how many genres are liked) as the largest driver of variation in the data, and remaining PCs help distinguish between more specific genre tastes.

Pros:

- Magnitude-based clusters can translate into actionable insights (e.g., people who choose many genres may also be more engaged or more likely to take certain behaviors of interest than those who choose fewer).
- PC2 captures largest residual differences in genre tastes, easily interpretable biplot (magnitude + taste axes)

Cons:

- There might be times when magnitude-based clusters are not as useful or interesting as other kinds of clusters. Since K means forces hard assignments, clustering based on magnitude groups people based on genre count which can obscure taste patterns that emerge with alternative ways to estimate similarity (see next analysis).

## Aggregate Proportions - Circular

The following polar figure plots the proportions of genres selected by each cluster. I chose a circular format because the shape quickly visually shows whether there are magnitude differences (larger vs smaller more circular shapes) or specific genre tastes (directional shapes that point towards constellations of genres). It corroborates the cluster interpretations above from the biplot.

```{r}
# Pivot long to plot proportions by cluster
plot_data <- dat_num %>%
  # Add cluster labels
  mutate(kclusters = k_clusters) %>%
  pivot_longer(
    cols = c(AltRock:Soul),  # all clustering variables
    names_to = "Variable",
    values_to = "Score"
  )

# Get proportions per cluster & genre
plot_summary <- plot_data %>%
  group_by(kclusters, Variable) %>%
  summarise(MeanScore = mean(Score, na.rm = TRUE), .groups = "drop")

# Plot proportions
ggplot(plot_summary, aes(x = Variable, y = MeanScore,
                         fill = factor(kclusters), group = kclusters)) +
  geom_line(size = 1) +
  facet_wrap(~ kclusters) +
  theme_bw() +
  geom_area(alpha = 0.3, position = "identity") +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, color = "black", size = 8)
  ) +
  labs(y = "Proportion Selected", x = "Genres", fill = 'Cluster')+
  coord_polar()
```

## Aggregate Proportions 

The following plots the same aggregate proportions per cluster, but as an area plot so that it is easier to compare patterns and magnitude across clusters.

```{r}
# Same plot but in area style
ggplot(plot_summary, aes(x = Variable, y = MeanScore,
                         fill = factor(kclusters), group = kclusters)) +
  geom_line(size = 1) +
  facet_wrap(~ kclusters) +
  theme_bw() +
  geom_area(alpha = 0.3, position = "identity") +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, color = "black", size = 9)
  ) +
  labs(y = "Proportion Selected", x = "Genres", fill = 'Cluster')
```


## Individual Preference Heatmap

To better understand the raw data patterns behind the clusters, we can plot every respondent as a row in a respondent × genre heatmap. Each column is a genre, and each cell is shaded green if the respondent selected that genre and white if not. Rows are ordered and grouped by cluster, so each cluster appears as a block of respondents with similar patterns - they are ordered from most prototypical (top) to least (bottom) within each cluster. This view exposes the individual-level patterns that give rise to the clusters. 

For example, Cluster 1 shows a lot of green and it is the generalist cluster, while Cluster 4 shows a more sparse heatmap as it is the least interested cluster (with few genre exceptions). Clusters 2 and 3 show green bands in the genres they prefer and smattered white elsewhere, reflecting speficificity in taste.

```{r}

# Helper functions to order the heatmap from most to least protoypical respondents within each cluster
# Get cosine similarity
cosine_sim <- function(x, y) sum(x*y) / (sqrt(sum(x^2)) * sqrt(sum(y^2)))

# Calculate row order by comparing each row/respondent to the cluster centroid
order_within_cluster <- function(mat, cluster_vec) {
  out_order <- vector("integer", length(cluster_vec))
  
  # Loop through each cluster
  for (cl in unique(cluster_vec)) {
    # Identify relevant respondents
    idx <- which(cluster_vec == cl)
    # Pull them out
    submat <- mat[idx, , drop = FALSE]
    # Calculate centroid based on cluster respondents
    centroid <- colMeans(submat, na.rm = TRUE)
    # Compare each row to centroid
    sim <- apply(submat, 1, function(x) cosine_sim(x, centroid))
    # Reorder based on similarity to centroid
    out_order[idx] <- idx[order(sim, decreasing = FALSE)] #False so order correct in plot
  }
  
  out_order
}

# Create the heatmap
row_order <- order_within_cluster(dat_num, k_clusters)

heat_df <- dat_num %>%
  mutate(Respondent = factor(row_number(), levels = row_order),
         Cluster = factor(k_clusters)) %>%
  pivot_longer(
    cols = AltRock:Soul,   # ONLY the genre columns
    names_to = "Genre",
    values_to = "Selected"
  )

ggplot(heat_df, aes(x = Genre, y = reorder(Respondent, Cluster), fill = factor(Selected))) +
  geom_tile() +
  facet_grid(rows = vars(Cluster), scales = "free_y", space = "free_y") +
  scale_fill_manual(values = c("0" = "white", "1" = "forestgreen")) +
  theme_bw() +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.text.x = element_text(angle = 90, hjust = 1, color = "black", size = 8)
  ) +
  labs(x = "Genre", y = "Respondents", fill = "Selected")

```

# K Means - Person x Person Correlation Matrix

```{r}
# First we need to create the person x person correlation matrix

# Keep track of resonse IDs (just to make the correlation matrix more interpretable)
id_vec <- dat$ResponseId

# filter out respondents with zero variance
dat_num <- dat %>% select(-ResponseId)
row_sds <- apply(dat_num, 1, sd, na.rm = TRUE)
dat_num_nozerovar <- dat_num[row_sds > 0, ]
id_vec   <- id_vec[row_sds > 0]  # keep IDs aligned

# transpose, items as rows and people as columns
dat_num_t <- as.data.frame(t(dat_num_nozerovar))

# name columns as people, rows as items
colnames(dat_num_t) <- id_vec
rownames(dat_num_t) <- colnames(dat_num_nozerovar)

# Create person-level correlation matrix
corrmat <- dat_num_t %>% 
    cor() 
```


## PCA Biplot

In this biplot, the four clusters and arrows are rearranged differently than the K Means Raw biplot, they are more distributed around the 0,0 point and the arrows show more variation in length.

Cluster interpretations:

- Cluster 1: Prefers Country, pop, classic rock
- Cluster 2: Likes all kinds of genres that are more niche/experimental (World, Jazz, Classical, Blues, Funk, Indie, etc)
- Cluster 3: Prefers R&B, Rap, Soul, Gospel, etc
- Cluster 4: Prefers the harder rocks (Punk, Metal, AltRock, ClassicRock, etc)

Principal Components interpretations:
- PC1: Cultural roots (from euro-anglo to afro-diasporic genres)
- PC2: Mainstream to Eclectic genres

```{r}
# Run K Means, Batched because of large matrix
set.seed(10) # for reproducibility
corr_k_means <- MiniBatchKmeans(corrmat, clusters = k, batch_size = 500, num_init = 10)
# Save cluster assignments
corr_clusters = predict_KMeans(corrmat, corr_k_means$centroids)


# ask only for first 10 components 
pcs_fast <- prcomp_irlba(corrmat, n = 10, scale. = TRUE)

# Get scores and add cluster
scores <- as.data.frame(pcs_fast$x[, 1:2])    # respondent positions
scores$cluster <- factor(corr_clusters)    # add cluster assignment

# correlate PCs with original items for arrows
cor_with_items <- cor(scores[,1:2], dat_num_nozerovar, use = "pairwise.complete.obs")
cor_with_items <- as.data.frame(t(cor_with_items))  
cor_with_items$Variable <- rownames(cor_with_items)

arrow_scale <- 120 # to scale the arrows for readability
clusternames = levels(scores$cluster)

# Need to find convex hull of each cluster
hull_points <- scores %>%
  group_by(cluster) %>%
  slice(chull(PC1, PC2))

# cluster plot with arrows and labels
ggplot(scores, aes(x = PC1, y = PC2, color = cluster, shape = cluster)) +
  geom_point(alpha = 0.4) +
  theme_classic() +
  ggtitle("MiniBatchKmeans Clusters (PCA projection)") +
  geom_polygon(data = hull_points, aes(fill = cluster), 
               alpha = 0.1) +
  theme_classic() +
  geom_segment(data = cor_with_items,
               aes(x = 0, y = 0, xend = PC1 * arrow_scale, yend = PC2 * arrow_scale),
               arrow = arrow(length = unit(0.2,"cm")),
               inherit.aes = FALSE, color = "black") +
  ggrepel::geom_text_repel(data = cor_with_items,
               aes(x = PC1 * (arrow_scale + 0.5),
                   y = PC2 * (arrow_scale + 0.5),
                   label = Variable),
               inherit.aes = FALSE,
               size = 5, color = "black", max.overlaps = 100) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey40") + 
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey40") +
  scale_color_discrete(labels = clusternames, name = "Cluster") +
  scale_shape_discrete(labels = clusternames, name = "Cluster") +
  guides(fill = "none") +
  ggtitle('') +
  theme(legend.position = "top",
        legend.direction = "horizontal",
        legend.title = element_text(size = 15),
        legend.text  = element_text(size = 11)) 
```

This highlights a likely outcome of K Means clustering with person x person correlation matrix as input, which uses **correlation** to determine similarity: 

Magnitude is not represented because correlations don’t reflect how many genres a person likes, only whether their relative pattern of preferences (the *shape* of which genres they choose or dont) aligns with others. Instead, the biplot and clusters resemble a preference map, capturing differences in specific genre tastes along dimensions that better differentiate between kinds of genres/types of listeners.

*Note: a “mainstream vs. eclectic” dimension didn’t appear in the raw k-means PCA biplot because the first component was dominated by magnitude (number of genres selected). That distinction might emerge in later components (or not), but it likely explains less variance than sheer magnitude. In contrast, when using correlation similarity — which removes magnitude as a feature — the preference-based dimensions (such as mainstream vs. eclectic) can appear more prominently.*

Pros:

- By ignoring magnitude and focusing on pattern similarity, the PCA space surfaces taste dimensions (e.g., mainstread vs eclectic) that are hidden in magnitude-based clustering.
- Clusters are more well seperated along the principal components, with clearly different taste profiles

Cons:

- Correlation requires variance: respondents who select all genres or none (even if genuine) provide no variability and must be excluded. This reduces the usable sample and means the clusters do not account for these kinds of respondents (e.g., total generalists or anti-music).

## Aggregate Proportions - Circular

The following shows the proportions of genres selected by each cluster as a polar plot. Unlike the K Means Raw version, you can see that the clusters' shapes are relatively similar overall size, it is their directional shape that differ (pointing towards different consterllations of genres), consistent with the biplot interpretation above.

```{r}
plot_data <- dat_num_nozerovar %>%
  mutate(corrclusters = corr_clusters) %>%
  pivot_longer(
    cols = c(AltRock:Soul),  # all clustering variables
    names_to = "Variable",
    values_to = "Score"
  )

plot_summary <- plot_data %>%
  group_by(corrclusters, Variable) %>%
  summarise(MeanScore = mean(Score, na.rm = TRUE), .groups = "drop")

ggplot(plot_summary, aes(x = Variable, y = MeanScore,
                         fill = factor(corrclusters), group = corrclusters)) +
  geom_line(size = 1) +
  facet_wrap(~ corrclusters) +
  theme_bw() +
  geom_area(alpha = 0.3, position = "identity") +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, color = "black", size = 9)
  ) +
  labs(y = "Proportion Selected", x = "Genres", fill = 'Cluster')+
  coord_polar()
```

## Aggregate Proportions 

Same proportions as above, but in a non-circular format. Can see the relative similarity in overall magnitude, but difference in genre preference shape.

```{r}
ggplot(plot_summary, aes(x = Variable, y = MeanScore,
                         fill = factor(corrclusters), group = corrclusters)) +
  geom_line(size = 1) +
  facet_wrap(~ corrclusters) +
  theme_bw() +
  geom_area(alpha = 0.3, position = "identity") +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, color = "black", size = 8)
  ) +
  labs(y = "Proportion Selected", x = "Genres", fill = 'Cluster')
```

## Individual Preference Heatmap

In this heatmap, Clusters 1,3,4 show green bands where their prefered genres are and smattered whiteness elsewhere (a pattern that reflects taste specificity), while Cluster 2 shows a smattering of green across genres (more density on classical) suggesting this cluster contains more eclectic/idiosyncratic listeners (that's what separates them from the other clusters).

It is also clearer to see how it doesn't consider magnitude as each cluster holds people that have more and less overall genre selections.

*Just a note: Correlating the respondent rows (the on/off pattern of green and white) is what creates the person x person correlation matrix.*

```{r}

#Create teh heatmap
row_order <- order_within_cluster(dat_num_nozerovar, corr_clusters)

heat_df <- dat_num_nozerovar %>%
  mutate(Respondent = factor(row_number(), levels = row_order),
         Cluster = factor(corr_clusters)) %>%
  pivot_longer(
    cols = AltRock:Soul,   # ONLY the genre columns
    names_to = "Genre",
    values_to = "Selected"
  )

ggplot(heat_df, aes(x = Genre, y = reorder(Respondent, Cluster), fill = factor(Selected))) +
  geom_tile() +
  facet_grid(rows = vars(Cluster), scales = "free_y", space = "free_y") +
  scale_fill_manual(values = c("0" = "white", "1" = "forestgreen")) +
  theme_bw() +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.text.x = element_text(angle = 90, hjust = 1, color = "black", size = 8)
  ) +
  labs(x = "Genre", y = "Respondents", fill = "Selected")

```

# K Means - Person x Person Jaccard Similarity Matrix

```{r}
# --- Jaccard Similarity Matrix via matrix algebra ---
a       <- rowSums(dat_num)                   # size of each person's set
inter   <- tcrossprod(as.matrix(dat_num))                # intersections |A ∩ B|
union   <- outer(a, a, "+") - inter           # unions |A ∪ B|

J <- matrix(0, nrow(dat_num), nrow(dat_num))  #initiate with 0 to account for 0 straightlining
nz <- union > 0
J[nz] <- inter[nz] / union[nz]               # Jaccard = |∩| / |∪|
diag(J) <- 1                                  # define self-similarity

jaccard_sim = J
```

## PCA Biplot

This biplot looks like a combination of the previous biplots, the arrows are all generally pointing in one direction like the K Means Raw biplot (with the exception that the direction is off-axis, now towards the lower-left diagonal) and the clusters are evenly distributed around the PCs like the K Means Correlation biplot. It's a little harder to read, but not impossible. 

*Note: Jaccard is not a euclidean metric (it reflects set-based similarity - intersection/union), which PCA decomposes variance in a euclidean feature space, so a biplot in the case of Jaccard is an approximation of relationships, not an exact visualization.*

Cluster interpretations:

- Cluster 1: Strong preference for classic rock/country, not much else systematically
- Cluster 2: Strong preference for R&B, Rap, and Soul and also not much else systematically.
- Cluster 3: Tend to like a lot of the genres, generalists
- Cluster 4: Least interested in music genres (slight interest in country, pop)

PCs interpretations:

- PC1: Cultural roots (from afro-diasporic to euro-anglo genres) AND it seems maybe also accounts for mainstream (both ends) vs eclectic (center)
- PC2: Magnitude of interest (how many genres are liked)

```{r}
set.seed(10)
jacc_k_means <- MiniBatchKmeans(jaccard_sim, clusters = k, batch_size = 500, num_init = 10)
jacc_clusters = predict_KMeans(jaccard_sim, jacc_k_means$centroids)


# ask only for first 10 components (enough for 2D plot + stability checks)
pcs_fast <- prcomp_irlba(jaccard_sim, n = 10, scale. = TRUE)

# mimic original code
scores <- as.data.frame(pcs_fast$x[, 1:3])    # respondent positions
scores$cluster <- factor(jacc_clusters)    # add cluster assignment

# correlate PCs with original items
cor_with_items <- cor(scores[,1:3], dat_num, use = "pairwise.complete.obs")
cor_with_items <- as.data.frame(t(cor_with_items))  
cor_with_items$Variable <- rownames(cor_with_items)

arrow_scale <- 120 # to scale the arrows for readability
clusternames = levels(scores$cluster)

# Need to find convex hull of each cluster
hull_points <- scores %>%
  group_by(cluster) %>%
  slice(chull(PC1, PC3))

# cluster plot with arrows and labels
ggplot(scores, aes(x = PC1, y = PC3, color = cluster, shape = cluster)) +
  geom_point(alpha = 0.4) +
  theme_classic() +
  ggtitle("MiniBatchKmeans Clusters (PCA projection)") +
  geom_polygon(data = hull_points, aes(fill = cluster), 
               alpha = 0.1) +
  theme_classic() +
  geom_segment(data = cor_with_items,
               aes(x = 0, y = 0, xend = PC1 * arrow_scale, yend = PC3 * arrow_scale),
               arrow = arrow(length = unit(0.2,"cm")),
               inherit.aes = FALSE, color = "black") +
  ggrepel::geom_text_repel(data = cor_with_items,
               aes(x = PC1 * (arrow_scale + 0.5),
                   y = PC3 * (arrow_scale + 0.5),
                   label = Variable),
               inherit.aes = FALSE,
               size = 5, color = "black", max.overlaps = 100) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey40") + 
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey40") +
  scale_color_discrete(labels = clusternames, name = "Cluster") +
  scale_shape_discrete(labels = clusternames, name = "Cluster") +
  guides(fill = "none") +
  ggtitle('') +
  theme(legend.position = "top",
        legend.direction = "horizontal",
        legend.title = element_text(size = 15),
        legend.text  = element_text(size = 11)) 
```


This highlights one outcome of K Means clustering with Jaccard similarity as input, which uses **Jaccard** to determine similarity:

Jaccard balances both magnitude (how many genres are selected) and taste patterns (which genres overlap). Unlike K means, the relative influence is flipped: the first principal component reflects taste differences, while the second component reflects magnitude. Compared to raw Euclidean K means clustering, Jaccard can downweight sheer magnitude and upweight overlap in specific genres, which can make preference-based distinctions more prominent.

This creates more exaggerated clusters: a high magnitude cluster that spands many genres (including eclectic ones), a low magnitude cluster with little systematic genre interest, and two taste-focused clusters split along very popular but distinctgenres (rap/R&B vs classic rock/country).

Pros:

- Combines the pros of identifying both magnitude and preference-based clusters.

Cons:

- Clusters & PCs are a bit harder to interpret in biplot since it acts like a hybrid between raw and correlation-based K means, more nuance dimensions (mainstream vs eclectic) are not as obvious unless already know to look for them (even then, still blurry and hard to pull out in the cluster interpretation).

## Aggregate Proportions - Circular

In the polar plots, it is much easier to see the exaggeration: the bottom row is the magnitude clusters (shape is either larger or small), while the top row shows the magnified classic rock/rap+R&B split.

```{r}
plot_data <- dat_num %>%
  mutate(jaccclusters = jacc_clusters) %>%
  pivot_longer(
    cols = c(AltRock:Soul),  # all clustering variables
    names_to = "Variable",
    values_to = "Score"
  )

plot_summary <- plot_data %>%
  group_by(jaccclusters, Variable) %>%
  summarise(MeanScore = mean(Score, na.rm = TRUE), .groups = "drop")

ggplot(plot_summary, aes(x = Variable, y = MeanScore,
                         fill = factor(jaccclusters), group = jaccclusters)) +
  geom_line(size = 1) +
  facet_wrap(~ jaccclusters) +
  theme_bw() +
  geom_area(alpha = 0.3, position = "identity") +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, color = "black", size = 8)
  ) +
  labs(y = "Proportion Selected", x = "Genres", fill = 'Cluster')+
  coord_polar()
```

## Aggregate Proportions 

Same proportions in non-circular form, which also shows the more modal spikes in clusters 1 and 2 and diffuseness with different magnitudes for clusters 3 and 4.

```{r}
ggplot(plot_summary, aes(x = Variable, y = MeanScore,
                         fill = factor(jaccclusters), group = jaccclusters)) +
  geom_line(size = 1) +
  facet_wrap(~ jaccclusters) +
  theme_bw() +
  geom_area(alpha = 0.3, position = "identity") +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, color = "black", size = 9)
  ) +
  labs(y = "Proportion Selected", x = "Genres", fill = 'Cluster')
```

## Individual Preference Heatmap

Reflects the same patterns seen in biplot and aggregate proportions, but at individual levels. Each cluster's prototype is viewable by looking for the green bands and towards the top of each plot.

```{r}

#Create teh heatmap
row_order <- order_within_cluster(dat_num, jacc_clusters)

heat_df <- dat_num %>%
  mutate(Respondent = factor(row_number(), levels = row_order),
         Cluster = factor(jacc_clusters)) %>%
  pivot_longer(
    cols = AltRock:Soul,   # ONLY the genre columns
    names_to = "Genre",
    values_to = "Selected"
  )

ggplot(heat_df, aes(x = Genre, y = reorder(Respondent, Cluster), fill = factor(Selected))) +
  geom_tile() +
  facet_grid(rows = vars(Cluster), scales = "free_y", space = "free_y") +
  scale_fill_manual(values = c("0" = "white", "1" = "forestgreen")) +
  theme_bw() +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.text.x = element_text(angle = 90, hjust = 1, color = "black", size = 8)
  ) +
  labs(x = "Genre", y = "Respondents", fill = "Selected")

```

# Latent Class Analysis

```{r}
# setup & helper functions
pacman::p_load(poLCA, weights)


compare_poLCA_models <- function(models) {
  
  # Extract information criteria and log-likelihood for each model
    results <- lapply(seq_along(models), function(i) {
        data.frame(
        Model = names(models)[i],
        AIC = models[[i]]$aic,
        BIC = models[[i]]$bic,
        LogLik = models[[i]]$llik
        )
    })
  
  # Combine results into a single data frame
  combined_results <- do.call(rbind, results)
  
  # Sort by preferred criteria (lower AIC/BIC)
  combined_results <- combined_results[order(combined_results$AIC), ] 
  
  return(combined_results)
}

```

```{r}
#Fit the model with various number of classes

#if model list file exists
if(file.exists("LCA_model_list.rds")){
  modlist <- readRDS("LCA_model_list.rds")
  #if model list file does not exist and have to run everything from scratch (takes a bit)
} else {
  f1 <- as.formula(
    # Combine and insert all the column names into model formula
    paste("cbind(", paste(sprintf("`%s`", names(dat_num)), collapse = ","), ") ~ 1")
    )

  #create an empty list to fill with models
  modlist <- list()
  class_nums <- 2:10

  for(i in class_nums){
    #run the model and insert into list
    # add 1 to responses as LCA assumes responses start at 1
    modlist[[i]] <- poLCA(f1, data=dat_num+1, nclass=i,  maxiter=5000, nrep=10)
    #name the list elements
    names(modlist)[i] <- paste0("LCA", i)
  }

  # remove the first element of the list (not used)
  modlist <- modlist[-1]

  #save list
  saveRDS(modlist, file = "LCA_model_list.rds")
}
```

```{r}
#| eval: false

#compare metrics

# Just a check, looks like k=4 should be fine as a solution

#collect the metrics for all the models
metrics = compare_poLCA_models(modlist) %>% 
  # turn Model into a factor and put in numerical order
  mutate(Model = factor(Model, levels = paste0('LCA', 2:10)))

#plot it
pivot_longer(metrics, cols = c("AIC", "BIC", "LogLik")) %>% 
  ggplot(aes(x = Model, y = value, color = name, group = name)) +
  geom_line() +
  facet_grid(rows = vars(name), scales = "free_y") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = "Model", y = "Value", color = "Metric")+
  geom_text(aes(label = round(value, 0)), position = position_dodge(width = 0.9), vjust = 1, size = 3) + 
  theme_bw()+ 
  scale_y_continuous(expand = expansion(mult = c(0.1, 0.1)))
```

```{r}  
# Plot the results

# Extract class proportions
classprop = data.frame(Class = paste0('class ', 1:(k), ": "), 
                      Proportion = rd(modlist[[k-1]]$P, 2)) %>% 
            mutate(Class = factor(Class, levels = paste0('class ', 1:(k), ": ")))

# Extract response probabilities by class & format for ggplot
modlist[[k-1]]$probs %>% 
    reshape2::melt(.) %>% 
    mutate(Var2 = case_when(Var2 == 'Pr(1)' ~ "Not Selected",
                            Var2 == 'Pr(2)' ~ "Selected")) %>% 
    mutate(Var2 = factor(Var2, levels = c("Selected", "Not Selected")), Var1=as.character(Var1)) %>%
    rename("Class" = Var1, "Response" = Var2, "Topic" = L1, 'Probability' = value) %>%
    left_join(classprop) %>%
    mutate(Class = paste0(Class, Proportion)) %>%
    filter(Response == "Selected") %>%
    ggplot(aes(x = Topic, y = Probability,
                         fill = factor(Class), group = Class)) +
      geom_line(size = 1) +
      facet_wrap(~ Class) +
      theme_bw() +
      geom_area(alpha = 0.3, position = "identity") +
      theme(
        axis.text.x = element_text(angle = 45, hjust = 1, color = "black", size = 8)
      ) +
      labs(y = "Proportion Selected", x = "Genres", fill = 'Cluster')+
      coord_polar()
```

```{r}
# Extract response probabilities by class & format for ggplot
modlist[[k-1]]$probs %>% 
    reshape2::melt(.) %>% 
    mutate(Var2 = case_when(Var2 == 'Pr(1)' ~ "Not Selected",
                            Var2 == 'Pr(2)' ~ "Selected")) %>% 
    mutate(Var2 = factor(Var2, levels = c("Selected", "Not Selected")), Var1=as.character(Var1)) %>%
    rename("Class" = Var1, "Response" = Var2, "Topic" = L1, 'Probability' = value) %>%
    left_join(classprop) %>%
    mutate(Class = paste0(Class, Proportion)) %>%
    filter(Response == "Selected") %>%
    ggplot(aes(x = Topic, y = Probability,
                         fill = factor(Class), group = Class)) +
      geom_line(size = 1) +
      facet_wrap(~ Class) +
      theme_bw() +
      geom_area(alpha = 0.3, position = "identity") +
      theme(
        axis.text.x = element_text(angle = 45, hjust = 1, color = "black", size = 8)
      ) +
      labs(y = "Proportion Selected", x = "Genres", fill = 'Cluster')

```


```{r}

lca_classes = modlist[[k-1]]$predclass

#Create teh heatmap
row_order <- order_within_cluster(dat_num, lca_classes)

heat_df <- dat_num %>%
  mutate(Respondent = factor(row_number(), levels = row_order),
         Cluster = factor(lca_classes)) %>%
  pivot_longer(
    cols = AltRock:Soul,   # ONLY the genre columns
    names_to = "Genre",
    values_to = "Selected"
  )

ggplot(heat_df, aes(x = Genre, y = reorder(Respondent, Cluster), fill = factor(Selected))) +
  geom_tile() +
  facet_grid(rows = vars(Cluster), scales = "free_y", space = "free_y") +
  scale_fill_manual(values = c("0" = "white", "1" = "forestgreen")) +
  theme_bw() +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.text.x = element_text(angle = 90, hjust = 1, color = "black", size = 8)
  ) +
  labs(x = "Genre", y = "Respondents", fill = "Selected")

```